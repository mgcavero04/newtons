from math import *
import numpy as np
# The 2 lines above can be omitted
# Run this file can be run from command promp(python installed) from its location with: python mnP1.py

# The program begins asking for initial required values.
# Then the call to the the Newton and Secant methods are saved in two variables: lambda2 and lambda1 respectively.
# Each function pass its own parameters as especified in the requirement
# Then both of those variables are called so each of the functions can run one after another.
# The derivative function is called and passed in another variable: 'f_prime' for the Newtons method
# each of the methods show each of the iterations before showing the convergence solution value.

def Newton(f, f_prime, p0,tol,N0): # p0=x^(k-1), p1=x^(k), p2=x^(k+1), tol=epsilon(tolerance), N=iterations, y f=function of f(x) definition.
    print("----Begin of Newtons:")
    i=1 # minimun iterations 
    lambda2 = [] 
    while i<=N0:
        p2= p0 - f(p0)/derivative(f, p0) # newtons method
        print(i,p2) 
        if tol==0 and abs(p2-p0) < 10**-12:
           lambda2.append(p2)
           lambda2.append(i)
           lambda2.append(p0)
           return lambda2
        elif  abs(p2-p0) < tol: # stopping criterion
           lambda2.append(p2)
           lambda2.append(i)
           lambda2.append(p0)
           return lambda2
                    #return p2,i # will return p2 roots until the above stopping criterion
       
        i=i + 1
        p0=p2
        
    print('The method failed after N0 iterations, N0= ', N0) # No results
    return None
def Secant(f,p0,p1,tol,N0): # p0=x^(k-1), p1=x^(k), p2=x^(k+1), tol=epsilon(tolerance), N=iterations, y f=function of f(x) definition.
    print("----Begin of Secants:")
    i=2 # minimun iterations 
    q0=f(p0)
    q1=f(p1)
    lambda1 = [] 
    while i<=N0:
        p2= p1 - (p1-p0)*q1/(q1-q0) # secant method
        print(i,p2) 
        if tol==0 and abs(p2-p1) < 10**-12:
           lambda1.append(p2)
           lambda1.append(i)
           return lambda1
        elif abs(p2-p1) < tol : # stopping criterion
            lambda1.append(p2)
            lambda1.append(i)
            return lambda1
            #return p2,i # will return p2 roots until the above stopping criterion
        i=i + 1
        p0=p1
        q0=q1
        p1=p2
        q1=f(p2)
    print('The method failed after N0 iterations, N0= ' %N0) # No results
    return None
def f(x):
    return (2.5/(7+x))**2+(1.5/(4+x))**2+(0.1/(0.3+x))**2-0.01
lambda_0=float(input("Enter value of x0: ")) 
lambda_1=float(input("Enter value of x1: ")) 
epsilon=float(input("Enter value of Ïµ or 0 (10**-12): ")) 
maxits=int(input("Enter value of # of interactions: ")) 
def derivative(function, value):
    h = 0.00000000001
    top = function(value + h) - function(value)
    bottom = h
    slope = top / bottom
    return slope
f_prime=derivative(f, lambda_0)
lambda1 = Secant(f, lambda_0,lambda_1,epsilon,maxits) 
lambda2 = Newton(f, f_prime, lambda_0,epsilon,maxits) 
if(lambda1):
    print("The Secant procedure was succesful. The solution is:",lambda1[0], "at ", lambda1[1], "iteractions") #return from if loop when stopping criterion=true
if(lambda2):
    print("The Newton procedure was succesful. The solution is:",lambda2[0], "at ", lambda2[1], "iteractions")
